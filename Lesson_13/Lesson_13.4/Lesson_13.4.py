# Функция с возвратом значения
# Функция с возвратом значения похожа на функцию без возврата значения тем, что:
#   это набор инструкций, выполняющий определенную задачу;
#   когда нужно выполнить функцию, ее вызывают.
# Однако когда функция с возвратом значения завершается, она возвращает значение в ту часть программы,
# которая ее вызвала. Возвращаемое из функции значение используется как любое другое: оно может быть присвоено
# переменной, выведено на экран, использовано в математическом выражении (если это число) и т. д.

# Функцию с возвратом значения пишут точно так же, как и без, но она должна иметь инструкцию return.
# def название_функции():
#     блок_кода
#     return выражение

# Значение выражения, которое следует за ключевым словом return, будет отправлено в ту часть программы,
# которая вызвала функцию. Это может быть переменная либо выражение, к примеру, математическое.

# При изучении вещественных чисел мы решали задачу о переводе градусов по шкале Фаренгейта в градусы по шкале Цельсия
# по формуле C = (5 / 9) * (F - 32)
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result

# Задача этой функции — принять одно число temp в качестве аргумента – количество градусов по шкале Фаренгейта,
# и вернуть другое — количество градусов по шкале Цельсия.

# функция перевода градусов Фаренгейта в градусы Цельсия
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result

# основная программа
temp = float(input('Bвeдитe количество градусов по Фаренгейту: '))
celsius = convert_to_celsius(temp)
print(celsius)  # градусы Цельсия

# Использование инструкции return по максимуму
# Взглянем еще раз на функцию convert_to_celsius():
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result
# Обратите внимание, что внутри этой функции происходят две вещи: во-первых, переменной result присваивается значение
# выражения (5 / 9) * (temp - 32), и во-вторых, значение переменной result возвращается из функции. Эта функция хорошо
# справляется с поставленной перед ней задачей, но ее можно упростить. Поскольку инструкция return возвращает значение
# выражения, переменную result устраняем и переписываем функцию так:
def convert_to_celsius(temp):
    return (5 / 9) * (temp - 32)

# Использование нескольких return
def convert_grade(grade):
    if grade >= 90:
        return 5
    elif grade >= 80:
        return 4
    elif grade >= 70:
        return 3
    elif grade >= 60:
        return 2
    else:
        return 1

grade = int(input('Введите вашу отметку по 100-балльной системе: '))
print(convert_grade(grade))

# Функцию convert_grade() можно переписать с помощью одной инструкции return:
def convert_grade(grade):
    result = -1
    if grade >= 90:
        result = 5
    elif grade >= 80:
        result = 4
    elif grade >= 70:
        result = 3
    elif grade >= 60:
        result = 2
    else:
        result = 1
    return result

# Примечание. Функции с возвратом значения предоставляют те же преимущества, что функции без возврата значения:
#     упрощают программный код;
#     уменьшают дублирование кода;
#     упрощают тестирование кода;
#     увеличивают скорость разработки;
#     способствуют работе в команде.


# Решение задач
# Задача 1. Напишите функцию, которая возвращает длину гипотенузы прямоугольного треугольника по известным значениям его
# катетов.
# Решение. Для нахождения длины гипотенузы, нам нужно применить теорему Пифагора: квадрат гипотенузы прямоугольного
# треугольника, равен сумме квадратов его катетов. Другими словами, если a,b – длины катетов, а c – длина гипотенузы,
# то имеет место равенство:
#   c ** 2 == a ** 2 + b ** 2 ==> c = (a ** 2 + b ** 2) ** 0.5
# Функция, вычисляющая длину гипотенузы, может иметь вид:
def compute_hypotenuse(a, b):
    c = (a ** 2 + b ** 2) ** 0.5
    return c

print(compute_hypotenuse(3, 4))   # 5.0 длина гипотенузы треугольника с катетами 3 и 4
print(compute_hypotenuse(5, 12))  # 13.0 длина гипотенузы треугольника с катетами 5 и 12
print(compute_hypotenuse(1, 1))   # 1.4142135623730951 длина гипотенузы треугольника с катетами 1 и 1

# Одним из основных преимуществ функций является возможность их повторного использования для решения похожих задач.
# Рассмотрим задачу нахождения расстояния между двумя точками.

# Задача 2. Напишите функцию get_distance(x1, y1, x2, y2), вычисляющую расстояние между точками (x1; y1) и (x2; y2)
# Решение. Расстояние между двумя точками (x1; y1) и (x2; y2) определяется по формуле
# P = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5

# Несложно заметить, что искомое расстояние – это длина гипотенузы прямоугольного треугольника с катетами равными
# abs(x1 - x2) и abs(y1 - y2)
# Функция, вычисляющая расстояние между точками, может иметь вид:
def get_distance(x1, y1, x2, y2):
    return compute_hypotenuse(x1 - x2, y1 - y2)

# Для подсчета искомого расстояния мы используем уже созданную нами функцию compute_hypotenuse передавая ей в качестве
# аргументов числа x1 - x2 и y1 - y2.
# Основная программа имеет вид:
x1, y1 = float(input()), float(input())  # считываем координаты первой точки
x2, y2 = float(input()), float(input())  # считываем координаты второй точки
print(get_distance(x1, y1, x2, y2))      # вычисляем и выводим расстояние между точками

# Задача 3. Напишите функцию sum_digits(n), принимающую в качестве аргумента натуральное число и возвращающую сумму его
# цифр.
# Решение. Функция sum_digits(n) может иметь вид:
def sum_digits(n):
    result = 0
    while n > 0:
        result += n % 10
        n //= 10
    return result

n = int(input())
print(sum_digits(n))  # вычисляем и выводим сумму цифр считанного числа

# Задача 4. Напишите функцию compute_average(numbers), принимающую в качестве аргумента список чисел и возвращающую
# среднее значение элементов списка.
# Решение. Для подсчета среднего значения элементов списка нужно вычислить сумму всех элементов и их количество,
# то есть использовать функции sum() и len(). Функция compute_average(numbers) может иметь вид:
def compute_average(numbers):
    return sum(numbers) / len(numbers)

numbers = [1, 3, 5, 1, 6, 8, 10, 2]
print(compute_average(numbers))  # 4.5 вычисляем и выводим среднее значение элементов списка


# Слияние двух отсортированных списков
# Слияние двух отсортированных списков в один — важная задача в информатике. Она естественно возникает при сортировке
# списков c использованием сортировки слиянием.

# Пусть даны два отсортированных по возрастанию списка чисел list1 и list2:
list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]

# Простейшее решение задачи слияния списков использует списочный метод sort():
def merge(list1, list2):
    result = list1 + list2   # создаем результирующий список
    result.sort()            # сортируем список встроенным методом sort()
    return result            # возвращаем отсортированный список

list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]
list3 = merge(list1, list2)  # вызываем функцию слияния двух отсортированных списков
print(list3)  # [0, 3, 10, 11, 11, 12, 12, 20, 24, 26, 47, 47, 48, 53, 57, 58, 63, 65, 70, 77, 79, 80, 81, 84, 84, 90, 95]

# И хотя функция merge() полностью справляется с своей задачей, она абсолютно не учитывает то,
# что два списка list1 и list2 уже отсортированы.


# Быстрое слияние двух отсортированных списков в один
# Пусть мы имеем два уже отсортированных по возрастанию списка list1 и list2.
# Алгоритм быстрого слияния следующий:
#     1. Создаем численные указатели p1 = 0 и p2 = 0 на начала обоих списков list1 и list2 соответственно;
#     2. На каждом шаге берем меньший из двух элементов list1[p1] и list2[p2];
#     3. Записываем его в результирующий список;
#     4. Увеличиваем указатель на первый элемент списка (p1 или p2) из которого был взят элемент на 11;
#     5. Когда один из начальных списков закончился, добавляем все оставшиеся элементы второго списка
#       в результирующий список.
def quick_merge(list1, list2):
    result = []
    p1 = 0  # указатель на первый элемент списка list1
    p2 = 0  # указатель на первый элемент списка list2
    while p1 < len(list1) and p2 < len(list2):  # пока не закончился хотя бы один список
        if list1[p1] <= list2[p2]:
            result.append(list1[p1])
            p1 += 1
        else:
            result.append(list2[p2])
            p2 += 1
    if p1 < len(list1):  # прицепление остатка
        result += list1[p1:]
    if p2 < len(list2):
        result += list2[p2:]
    return result

list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]
list3 = quick_merge(list1, list2)
print(list3)  # [0, 3, 10, 11, 11, 12, 12, 20, 24, 26, 47, 47, 48, 53, 57, 58, 63, 65, 70, 77, 79, 80, 81, 84, 84, 90, 95]
